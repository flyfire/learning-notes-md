# 17.一个线程两次调用start()方法会出现什么情况？

Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException。

关于线程生命周期的不同状态，在Java 5以后，线程状态被明确定义在其公共内部枚举类java.lang.Thread.State中，分别是：

+ 新建(NEW)，表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。
+ 就绪(RUNNABLE)，表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。
+ 在其他一些分析中，会额外区分一种状态RUNNING，但是从Java API角度，并不能表示出来。
+ 阻塞(BLOCKED)，阻塞表示线程在等待monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。
+ 等待(WAITING)，表示正在等待其他线程采取某些操作，一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待(wait)，另外的生产者线程去准备任务数据，然后通过类似notify等 动作，通知消费者线程可以继续工作了。Thread.join()也会令线程进入等待状态。
+ 计时等待(TIMED_WAIT)，其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本。
+ 终止(TERMINATED)，不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫做死亡。

