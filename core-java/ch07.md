# 07.int和Integer有什么区别？

int是我们常说的整形数字，是Java的8个原始数据类型（Primitive Types，boolean、byte、short、chart、int、float、double、long）之一。Java语言虽然号称一切都是对象，但原始数据类型是例外。

Integer是int对应的包装类，它有一个int类型的字段存储数据，并且提供了基本操作，比如数学运算、int和字符串之间转换等。在Java 5中，引入了自动装箱和自动拆箱功能（boxing/unboxing），Java可以根据上下文，自动进行转换。

关于Integer的值缓存，这涉及Java 5中另一个改进。构建Integer对象的传统方式是直接调用构造器，直接new一个对象。根据实践，发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在Java 5中新增了静态工厂方法valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照Javadoc，这个值默认缓存是-128到127之间。

自动装箱实际上算是一种语法糖，可以简单理解为Java平台为我们自动进行了一些转换，保证不同的写法在运行时等价，它们发生在编译阶段，也就是生成的字节码是一致的。javac替我们自动把装箱替换为Integer.valueOf()，把拆箱替换为Integer.intValue()。

这种缓存机制并不是只有Integer才有，同样存在于其他的一些包装类，比如：

+ Boolean，缓存了true/false对应实例，确切说，只会返回两个常量实例Boolean.TRUE/FALSE。
+ Short，同样是缓存了-128到127之间的数值。
+ Byte，数值有限，所以全部都被缓存。(-128到127)
+ Character，缓存范围'\u0000'到'\u007F'

原始数据类型的变量，要使用并发相关手段，才能保证线程安全。如果有线程安全的计算需要，可以考虑使用类似AtomicInteger、AtomicLong这样的线程安全类。特别的是，部分比较宽的数据类型，比如float、double，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半数据位的数值！

原始数据类型和Java泛型不能配合使用，这是因为Java的泛型某种程度上可以算作伪泛型，它完全是一种编译期的技巧，Java编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为Object。

Java的对象都是引用类型，如果是一个原始数据类型数组，它在内存中是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代CPU缓存机制。

对象由三部分组成，对象头，对象实例，对齐填充。
其中对象头一般是十六个字节，包括两部分，第一部分有哈希码，锁状态标志，线程持有的锁，偏向线程id，gc分代年龄等。第二部分是类型指针，也就是对象指向它的类元数据指针，可以理解，对象指向它的类。
对象实例就是对象存储的真正有效信息，也是程序中定义各种类型的字段包括父类继承的和子类定义的，这部分的存储顺序会被虚拟机和代码中定义的顺序影响。
第三部分对齐填充只是一个类似占位符的作用，因为内存的使用都会被填充为八字节的倍数。