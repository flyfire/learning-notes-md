# 18.什么情况下Java程序会产生死锁，如何定位、修复？

死锁是一种特定的程序状态，在实体之间，由于循环依赖倒置彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。通常聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。

定位死锁最常见的方式就是利用jstack等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。

基本上死锁的发生是因为：

+ 互斥条件，类似Java中monitor都是独占的，要么是我用，要么是你用。
+ 互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其他线程抢占。
+ 循环依赖关系，两个或者多个个体之间出现了锁的链条环。

避免死锁的思路和方法：

+ 如果可能的话，尽量避免使用多个锁，并且只有需要时才持有锁。
+ 如果必须使用多个锁，尽量设计好锁的获取顺序。
+ 使用带超时的方法，为程序带来更多可控性。类似``Object.wait()``或者``CountDownLatch.await()``都支持所谓的timed_wait，可以不假定该锁一定会获得，指定超时时间，并未无法得到锁时准备推出逻辑。并发Lock实现，如ReentrantLock还支持非阻塞式的获取锁操作tryLock()，这是一个插队行为，并不在乎等待的公平性，如果执行时对象恰好没有被独占，则直接获取锁。
+ 通过静态代码分析(如FindBugs)去查找固定的模式，进而定位可能的死锁或者竞争情况。