# 22.AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？

AtomicInteger是对int类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于CAS(compare-and-swap)技术。

所谓CAS，表征的是一系列操作的集合，获取当前数值，进行一些运算，利用CAS指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或失败的结果。

CAS依赖于CPU提供的特定指令，具体根据体系结构的不同还存在着明显区别。比如x86 CPU提供cmpxchg指令；而在精简指令集的体系架构中，则通常是靠一对指令(如load and reserve和store conditional)实现的。

CAS并不是没有副作用，其常用的失败重试机制，隐含着一个假设，即竞争情况是短暂的。大多数应用场景中，确实大部分重试只会发生一次就获得了成功，但是总是有意外情况，所以在有需要的时候，还是要考虑限制自旋的次数，以免过度消耗CPU。另外一个就是著名的ABA问题，这是通常只在lock-free算法下暴露的问题。CAS是在更新时比较前值，如果对方只是恰好相同，例如期间发生了A-B-A的更新，仅仅判断数值是A，可能导致不合理的修改操作。针对这种情况，Java提供了AtomicStampedReference工具类，通过为引用建立类似版本号(stamp)的方式，来保证CAS的正确性。

AQS内部数据和方法，可以简单拆分为：

+ 一个volatile的整数成员表征状态，同时提供了setState和getState方法。``private volatile int state;``
+ 一个先入先出FIFO的等待线程队列，以实现多线程间竞争和等待，这是AQS机制的核心之一。
+ 各种基于CAS的基础操作方法，以及各种期望具体同步结构去实现的acquire/release方法。

利用AQS实现一个同步结构，至少要实现两个基本类型的方法，分别是acquire操作，获取资源的独占权；还有就是release操作，是否对某个资源的独占。

AQS中Node的waitStatus含义：

+ CANCELLED 1 因为超时或中断设置为此状态，标志节点不可用
+ SIGNAL -1 处于此状态的节点释放资源时会唤醒后面的节点
+ CONDITION -2 处于条件队列里，等待条件成立(signal signalall) 条件成立后会置入获取资源的队列里
+ PROPAGATE -3 共享模式下使用，头节点获取资源时将后面节点设置为此状态，如果头节点获取资源后还有足够的资源，则后面节点会尝试获取，这个状态主要是为了共享状态下队列里足够多的节点同时获取资源
+ 0 初始状态
