# 23.请介绍类加载过程，什么是双亲委派模型？

一般来说，我们把Java的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在Java虚拟机规范里由非常详细的定义。

首先是加载阶段(Loading)，它是Java将字节码数据从不同的数据源读取到JVM中，并映射为JVM认可的数据结构(Class对象)，这里的数据源可能是各种各样的形态，如jar文件、class文件，甚至是网络数据源等；如果输入数据不是ClassFile的结构，则会抛出ClassFormatError。

加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。

第二个阶段是链接(Linking)，这是核心的步骤，简单说是把原始的类定义信息平滑地转化如JVM运行的过程中。这里可进一步细分为三个步骤：

+ 验证(Verification)，这是虚拟机安全的重要保障，JVM需要核验字节信息是符合Java虚拟机规范的，否则就被认为是VerifyError，这样就防止了恶意信息或者不合规的信息危害JVM的运行，验证阶段有可能触发更多class的加载。
+ 准备(Preparation)，创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的”初始化“和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的JVM指令。
+ 解析(Resolution)，在这一步会将常量池中的符号引用(symbolic reference)替换为直接引用。在Java虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。

最后是初始化阶段(initialization)，这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。

双亲委派模型，简单说就是当类加载器ClassLoader试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载Java类型。

Java8以前各种类加载器的结构，下面是三种Oracle JDK内建的类加载器。

+ 启动类加载器(Bootstrap ClassLoader)，加载jre/lib下面的jar文件，如rt.jar。它是个超级公民，即使是在开启了Security Manager的时候，JDK仍赋予了它加载的程序All Permission。
+ 扩展类加载器(Extension ClassLoader)，负责加载我们放到jre/lib/ext目录下面的jar包，这就是所谓的extension机制。该目录也可以通过设置"java.ext.dirs"来覆盖。
+ 应用类加载器(Application ClassLoader)，就是加载我们最熟悉的classpath的内容。

通常类加载截止有三个基本特征：

+ 双亲委派模型。
+ 可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。
+ 单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器找那个重复加载。























