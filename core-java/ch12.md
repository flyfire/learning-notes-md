# 12.Java有几种文件拷贝方式？哪一种最高效？

Java有多种比较典型的文件拷贝实现方式，比如

+ 利用java.io类库，直接为源文件构建一个FileInputStream读取，然后再为目标文件构建一个FileOutputStream，完成写入工作。
+ 利用java.nio类库提供的transferTo或transferFrom方法实现。

用户态空间(User Space)和内核态空间(Kernel Space)，这是操作系统层面的基本概念，操作系统内核、硬件驱动等运行在内核态空间，具有相对高的特权；而用户态空间，则是给普通应用和服务使用。

当我们使用输入输出流进行读写时，实际上是进行了多次上下文切换，比如应用读取数据时，先在内核态将数据从磁盘读取到内核缓存，再切换到用户态将数据从内核缓存读取到用户缓存。写入操作也是类似，仅仅是步骤相反。所以，这种方式会带来一定的额外开销，可能会降低IO效率。

而基于NIO transferTo的实现方式，在Linux/Unix上，则会使用到零拷贝技术，数据传输并不需要用户态参与，省去了上下文切换的开销和不比较的内存拷贝，进而可能提高应用拷贝性能。注意，transferTo不仅仅是可以用在文件拷贝中，与其类似的，例如读取磁盘文件，然后进行Socket发送，同样可以享受这种机制带来的性能和扩展性提高。

从实践角度总结一下，如何提高类似拷贝等IO操作的性能，有一些宽泛的原则：

+ 在程序中，使用缓存等机制，合理减少IO次数(在网络通信中，如TCP传输，window大小也可以看作是类似思路)
+ 使用transferTo等机制，减少上下文切换和额外IO操作
+ 尽量减少不必要的转换过程，比如编解码；对象序列化和反序列化，比如操作文本文件或者网络通信，如果不是过程中需要使用文本信息，可以考虑不要将二进制信息转换成字符串，直接传输二进制信息。

Buffer是NIO操作数据的基本工具，Java为每种原始数据类型都提供了相应的Buffer实现(布尔除外)。

Buffer有几个基本属性：

+ capacity,它反映这个Buffer到底有多大，也就是数组的长度。
+ position,要操作的数据起始位置。
+ limit,相当于操作的限额。在读取或者写入时，limit的意义很明显是不一样的。比如，读取操作时，很可能将limit设置到所容纳数据的上限；而在写入时，则会设置容量或容量以下的可写限度。
+ mark,记录上一次position的位置，默认是0，算是一个便利性的考虑，往往不是必须的。

Buffer的基本操作：

+ 创建了一个ByteBuffer，准备放入数据，capacity当然就是缓冲区大小，而position就是0，limit默认就是capacity的大小。
+ 当我们写入几个字节的数据时，position就会跟着水涨船高，但是它不可能超过limit的大小。
+ 如果我们想把前面写入的数据读出来，需要调用flip方法，将position设置为0，limit设置为以前的position那里。
+ 如果还想从头再读一遍，可以调用rewind，让limit不变，position再次设置为0。

两种特别的Buffer:

+ Direct Buffer,Buffer的方法定义，它定义了``isDirect()``方法，返回当前Buffer是否是Direct类型。这是因为Java提供了堆内核堆外(Direct)Buffer，我们可以以它的allocate或者allocateDirect方法直接创建。
+ MappedByteBuffer，它将文件按照指定大小直接映射为内存区域，当程序访问这个内存区域时将直接操作这块文件数据，省去了将数据从内核空间向用户空间传输的损耗。可以使用``FileChannel.map``创建MappedByteBuffer，它本质上也是种Direct Buffer。

在实际使用中，Java会尽量对Direct Buffer仅做本地IO操作，对于很多大数据量的IO密集操作，可能会带来非常大的性能优势，因为：

+ Direct Buffer生命周期内内存地址都不会再发生更改，进而内核可以安全地对其进行访问，很多IO操作会很高效。
+ 减少了堆内对象存储的可能额外维护工作，所以访问效率可能有所提高。