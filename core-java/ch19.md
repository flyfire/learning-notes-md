# 19.Java并发包提供了哪些并发工具类？

通常所说的并发包就是java.util.concurrent及其子包，集中了Java并发的各种基础工具类，具体主要包括几个方面：

+ 提供了比synchronized更加高级的各种同步结构，包括CountDownLatch、CyclicBarrier、Semaphore等，可以实现更加丰富的多线程操作，比如利用Semaphore作为资源控制器，限制同时进行工作的线程数量。
+ 各种线程安全的容器，比如最常见的ConcurrentHashMap，有序的ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组CopyOnWriteArrayList等。
+ 各种并发队列实现，如各种BlockingQueue实现，比较典型的ArrayBlockingQueue、SynchronousQueue或针对特定场景的PriorityBlockingQueue等。
+ 强大的Executor框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。

进行多线程编程，无非是达到几个目的：

+ 利用多线程提高程序的扩展能力，以达到业务对吞吐量的要求。
+ 协调线程间调度、交互，以完成业务逻辑。
+ 线程间传递数据和状态，这同样是实现业务逻辑的需要。

CountDownLatch，允许一个或多个线程等待某些操作完成。

CyclicBarrier，一种辅助性的同步结构，允许多个线程等待到达某个屏障。

Semaphore，Java版本的信号量实现。

Semaphore就是个计数器，其基本逻辑基于acquire/release，并没有太复杂的同步逻辑。如果Semaphore的数值被初始化为1，那么一个线程就可以通过acquire进入互斥状态，本质上和互斥锁是非常相似的，但是区别也非常明显，比如互斥锁是有持有者的，而对于Semaphore这种计数器结构，虽然有类似功能，但其实不存在真正意义的持有者，除非进行扩展包装。

CountDownLatch和CyclicBarrier

+ CountDownLatch是不可以重复的，所以无法重用；而CyclicBarrier则没有这种限制，可以重用。
+ CountDownLatch的基本操作组合是countDown/await。调用await的线程阻塞等待countDown足够的次数，不管你是在一个线程还是多个线程里countDown，只要次数足够即可。CountDownLatch操作的是事件。
+ CyclicBarrier的基恩操作组合，则就是await，当所有的伙伴parties都调用了await，才会继续进行任务，并自动进行充值。注意，正常情况下，CyclicBarrier的重置都是自动发生的，如果我们调用reset方法，但还有线程在等待，就会导致等待线程被打扰，抛出BrokenBarrierException异常。CyclicBarrier侧重点是线程，而不是调用事件，它的典型应用场景是用来等待并发线程结束。

如果我们的应用侧重于Map放入或者获取的速度，而不在乎顺序，大多推荐使用ConcurrentHashMap，反之则使用ConcurrentSkipListMap。

为什么并发容器里面没有ConcurrentTreeMap呢？这是因为TreeMap要实现高效的线程安全是非常困难的，它的实现基于复杂的红黑树。为了保证访问效率，当我们插入或删除节点时，会移动节点进行平衡操作，这导致在并发场景中难以进行合理粒度的同步。而Skip List结构则要相对简单得多，通过层次结构提高访问速度，虽然不够紧凑，空间使用有一定提高(O(nlogn))，但是在增删元素时线程安全的开销要好很多。

CopyOnWriteArraySet是通过包装了CopyOnWriteArrayList来实现的。