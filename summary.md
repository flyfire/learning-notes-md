# Summary

* [Introduction](readme.md)
* [Java并发编程实战](java-concurrency-in-practice/readme.md)
    * [开篇词](java-concurrency-in-practice/intro.md)
    * [01.可见性、原子性和有序性问题](java-concurrency-in-practice/ch01.md)
    * [02.Java内存模型](java-concurrency-in-practice/ch02.md)
    * [03.互斥锁上](java-concurrency-in-practice/ch03.md)
    * [04.互斥锁下](java-concurrency-in-practice/ch04.md)
    * [05.死锁](java-concurrency-in-practice/ch05.md)
    * [06.等待通知](java-concurrency-in-practice/ch06.md)
    * [07.安全性、活跃性以及性能问题](java-concurrency-in-practice/ch07.md)
    * [08.管程](java-concurrency-in-practice/ch08.md)
    * [09.Java线程上](java-concurrency-in-practice/ch09.md)
    * [10.Java线程中](java-concurrency-in-practice/ch10.md)
    * [11.Java线程下](java-concurrency-in-practice/ch11.md)
    * [12.面向对象](java-concurrency-in-practice/ch12.md)
    * [13.理论基础答疑](java-concurrency-in-practice/ch13.md)
    * [14.Lock和Condition上](java-concurrency-in-practice/ch14.md)
    * [15.Lock和Condition下](java-concurrency-in-practice/ch15.md)
    * [16.Semaphore](java-concurrency-in-practice/ch16.md)
    * [17.ReadWriteLock](java-concurrency-in-practice/ch17.md)
    * [18.StampedLock](java-concurrency-in-practice/ch18.md)
    * [19.CountDownLatch和CyclicBarrier](java-concurrency-in-practice/ch19.md)
    * [20.并发容器](java-concurrency-in-practice/ch20.md)
    * [21.原子类](java-concurrency-in-practice/ch21.md)
    * [22.Executor与线程池](java-concurrency-in-practice/ch22.md)
    * [23.Future](java-concurrency-in-practice/ch23.md)
    * [24.CompletableFuture](java-concurrency-in-practice/ch24.md)
    * [25.CompletionService](java-concurrency-in-practice/ch25.md)
    * [26.Fork/Join](java-concurrency-in-practice/ch26.md)
    * [27.并发工具类答疑](java-concurrency-in-practice/ch27.md)
    * [28.Immutability模式](java-concurrency-in-practice/ch28.md)
    * [29.Copy-on-Write模式](java-concurrency-in-practice/ch29.md)
    * [30.线程本地存储](java-concurrency-in-practice/ch30.md)
    * [31.Guarded Suspension模式](java-concurrency-in-practice/ch31.md)
    * [32.Balking模式](java-concurrency-in-practice/ch32.md)
    * [33.Thread-Per-Message模式](java-concurrency-in-practice/ch33.md)
* [Java核心技术36讲](core-java/readme.md)
    * [01.对Java平台的理解](core-java/ch01.md)
    * [02.Exception/Error](core-java/ch02.md)
    * [03.final,finally,finalize](core-java/ch03.md)
    * [04.强、软、弱、虚引用](core-java/ch04.md)
    * [05.String,StringBuffer,StringBuilder](core-java/ch05.md)
    * [06.动态代理](core-java/ch06.md)
    * [07.int,Integer](core-java/ch07.md)
    * [08.Vector,ArrayList,LinkedList](core-java/ch08.md)
    * [09.Hashtable,HashMap,TreeMap](core-java/ch09.md)
    * [10.ConcurrentHashMap](core-java/ch10.md)
    * [11.IO/NIO](core-java/ch11.md)
    * [12.文件拷贝方式](core-java/ch12.md)
    * [13.接口和抽象类](core-java/ch13.md)
    * [14.设计模式](core-java/ch14.md)
    * [15.synchronized/ReentrantLock](core-java/ch15.md)
    * [16.synchronized底层实现](core-java/ch16.md)
    * [17.线程调用两次start](core-java/ch17.md)
    * [18.死锁](core-java/ch18.md)
    * [19.Java并发工具类](core-java/ch19.md)
    * [20.ConcurrentLinkedQueue和LinkedBlockingQueue区别](core-java/ch20.md)
    * [21.线程池](core-java/ch21.md)
    * [22.AtomicInteger底层实现原理](core-java/ch22.md)
    * [23.类加载过程](core-java/ch23.md)
    * [24.运行时动态生成Java类](core-java/ch24.md)
    * [25.JVM内存区域划分](core-java/ch25.md)
    * [26.监控和诊断JVM对内和堆外内存使用](core-java/ch26.md)
    * [27.Java常见垃圾收集器](core-java/ch27.md)
    * [28.GC调优思路](core-java/ch28.md)
    * [29.Java内存模型happen-before](core-java/ch29.md)
    * [30.Java&Docker](core-java/ch30.md)
    * [31.Java应用开发中注入攻击](core-java/ch31.md)
    * [32.安全Java代码](core-java/ch32.md)
    * [33.诊断后台服务](core-java/ch33.md)
    * [34.Lambda](core-java/ch34.md)
    * [35.JVM优化Java代码](core-java/ch35.md)
    * [36.MySQL支持的事务隔离级别](core-java/ch36.md)
    * [37.Spring Bean生命周期](core-java/ch37.md)
    * [38.Netty&NIO](core-java/ch38.md)
    * [39.分布式ID](core-java/ch39.md)
    * [40.书籍](core-java/ch40.md)
* [深入拆解Java虚拟机](deep-into-jvm/readme.md)
    * [开篇词 | 为什么我们要学习Java虚拟机？](deep-into-jvm/ch00.md)
    * [01 | Java代码是怎么运行的？](deep-into-jvm/ch01.md)
    * [02 | Java的基本类型](deep-into-jvm/ch02.md)
    * [03 | Java虚拟机是如何加载Java类的?](deep-into-jvm/ch03.md)
    * [04 | JVM是如何执行方法调用的？（上）](deep-into-jvm/ch04.md)
    * [05 | JVM是如何执行方法调用的？（下）](deep-into-jvm/ch05.md)
    * [06 | JVM是如何处理异常的？](deep-into-jvm/ch06.md)
    * [07 | JVM是如何实现反射的？](deep-into-jvm/ch07.md)
    * [08 | JVM是怎么实现invokedynamic的？（上）](deep-into-jvm/ch08.md)
    * [09 | JVM是怎么实现invokedynamic的？（下）](deep-into-jvm/ch09.md)
    * [10 | Java对象的内存布局](deep-into-jvm/ch10.md)
    * [11 | 垃圾回收（上）](deep-into-jvm/ch11.md)
    * [12 | 垃圾回收（下）](deep-into-jvm/ch12.md)
    * [13 | Java内存模型](deep-into-jvm/ch13.md)
    * [14 | Java虚拟机是怎么实现synchronized的？](deep-into-jvm/ch14.md)
    * [15 | Java语法糖与Java编译器](deep-into-jvm/ch15.md)
    * [16 | 即时编译（上）](deep-into-jvm/ch16.md)
    * [17 | 即时编译（下）](deep-into-jvm/ch17.md)
    * [18 | 即时编译器的中间表达形式](deep-into-jvm/ch18.md)
    * [19 | Java字节码（基础篇）](deep-into-jvm/ch19.md)
    * [20 | 方法内联（上）](deep-into-jvm/ch20.md)
    * [21 | 方法内联（下）](deep-into-jvm/ch21.md)
    * [22 | HotSpot虚拟机的intrinsic](deep-into-jvm/ch22.md)
    * [23 | 逃逸分析](deep-into-jvm/ch23.md)
    * [24 | 字段访问相关优化](deep-into-jvm/ch24.md)
    * [25 | 循环优化](deep-into-jvm/ch25.md)
    * [26 | 向量化](deep-into-jvm/ch26.md)
    * [27 | 注解处理器](deep-into-jvm/ch27.md)
    * [28 | 基准测试框架JMH（上）](deep-into-jvm/ch28.md)
    * [29 | 基准测试框架JMH（下）](deep-into-jvm/ch29.md)
    * [30 | Java虚拟机的监控及诊断工具（命令行篇）](deep-into-jvm/ch30.md)
    * [31 | Java虚拟机的监控及诊断工具（GUI篇）](deep-into-jvm/ch31.md)
    * [32 | JNI的运行机制](deep-into-jvm/ch32.md)
    * [33 | Java Agent与字节码注入](deep-into-jvm/ch33.md)
    * [34 | Graal：用Java编译Java](deep-into-jvm/ch34.md)
    * [35 | Truffle：语言实现框架](deep-into-jvm/ch35.md)
    * [36 | SubstrateVM：AOT编译框架](deep-into-jvm/ch36.md)
    * [尾声 | 道阻且长，努力加餐](deep-into-jvm/ch37.md)
* [数据结构与算法之美](the-beauty-of-data-structure-and-algorithms/readme.md)
    * [开篇词 | 从今天起，跨过“数据结构与算法”这道坎](the-beauty-of-data-structure-and-algorithms/ch00.md)
    * [01 | 为什么要学习数据结构和算法？](the-beauty-of-data-structure-and-algorithms/ch01.md)
    * [02 | 如何抓住重点，系统高效地学习数据结构与算法？](the-beauty-of-data-structure-and-algorithms/ch02.md)
    * [03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？](the-beauty-of-data-structure-and-algorithms/ch03.md)
    * [04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度](the-beauty-of-data-structure-and-algorithms/ch04.md)
    * [05 | 数组：为什么很多编程语言中数组都从0开始编号？](the-beauty-of-data-structure-and-algorithms/ch05.md)
    * [06 | 链表（上）：如何实现LRU缓存淘汰算法?](the-beauty-of-data-structure-and-algorithms/ch06.md)
    * [07 | 链表（下）：如何轻松写出正确的链表代码？](the-beauty-of-data-structure-and-algorithms/ch07.md)
    * [08 | 栈：如何实现浏览器的前进和后退功能？](the-beauty-of-data-structure-and-algorithms/ch08.md)
    * [09 | 队列：队列在线程池等有限资源池中的应用](the-beauty-of-data-structure-and-algorithms/ch09.md)
    * [10 | 递归：如何用三行代码找到“最终推荐人”？](the-beauty-of-data-structure-and-algorithms/ch10.md)
    * [11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？](the-beauty-of-data-structure-and-algorithms/ch11.md)
    * [12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？](the-beauty-of-data-structure-and-algorithms/ch12.md)
    * [13 | 线性排序：如何根据年龄给100万用户数据排序？](the-beauty-of-data-structure-and-algorithms/ch13.md)
    * [14 | 排序优化：如何实现一个通用的、高性能的排序函数？](the-beauty-of-data-structure-and-algorithms/ch14.md)
    * [15 | 二分查找（上）：如何用最省内存的方式实现快速查找功能？](the-beauty-of-data-structure-and-algorithms/ch15.md)
    * [16 | 二分查找（下）：如何快速定位IP对应的省份地址？](the-beauty-of-data-structure-and-algorithms/ch16.md)
    * [17 | 跳表：为什么Redis一定要用跳表来实现有序集合？](the-beauty-of-data-structure-and-algorithms/ch17.md)
    * [18 | 散列表（上）：Word文档中的单词拼写检查功能是如何实现的？](the-beauty-of-data-structure-and-algorithms/ch18.md)
    * [19 | 散列表（中）：如何打造一个工业级水平的散列表？](the-beauty-of-data-structure-and-algorithms/ch19.md)
    * [20 | 散列表（下）：为什么散列表和链表经常会一起使用？](the-beauty-of-data-structure-and-algorithms/ch20.md)
    * [21 | 哈希算法（上）：如何防止数据库中的用户信息被脱库？](the-beauty-of-data-structure-and-algorithms/ch21.md)
    * [22 | 哈希算法（下）：哈希算法在分布式系统中有哪些应用？](the-beauty-of-data-structure-and-algorithms/ch22.md)
    * [23 | 二叉树基础（上）：什么样的二叉树适合用数组来存储？](the-beauty-of-data-structure-and-algorithms/ch23.md)
    * [24 | 二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？](the-beauty-of-data-structure-and-algorithms/ch24.md)
    * [25 | 红黑树（上）：为什么工程中都用红黑树这种二叉树？](the-beauty-of-data-structure-and-algorithms/ch25.md)
    * [26 | 红黑树（下）：掌握这些技巧，你也可以实现一个红黑树](the-beauty-of-data-structure-and-algorithms/ch26.md)
    * [27 | 递归树：如何借助树来求解递归算法的时间复杂度？](the-beauty-of-data-structure-and-algorithms/ch27.md)
    * [28 | 堆和堆排序：为什么说堆排序没有快速排序快？](the-beauty-of-data-structure-and-algorithms/ch28.md)
    * [29 | 堆的应用：如何快速获取到Top 10最热门的搜索关键词？](the-beauty-of-data-structure-and-algorithms/ch29.md)
    * [30 | 图的表示：如何存储微博、微信等社交网络中的好友关系？](the-beauty-of-data-structure-and-algorithms/ch30.md)
    * [31 | 深度和广度优先搜索：如何找出社交网络中的三度好友关系？](the-beauty-of-data-structure-and-algorithms/ch31.md)
    * [32 | 字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？](the-beauty-of-data-structure-and-algorithms/ch32.md)
    * [33 | 字符串匹配基础（中）：如何实现文本编辑器中的查找功能？](the-beauty-of-data-structure-and-algorithms/ch33.md)
    * [34 | 字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法？](the-beauty-of-data-structure-and-algorithms/ch34.md)
    * [35 | Trie树：如何实现搜索引擎的搜索关键词提示功能？](the-beauty-of-data-structure-and-algorithms/ch35.md)
    * [36 | AC自动机：如何用多模式串匹配实现敏感词过滤功能？](the-beauty-of-data-structure-and-algorithms/ch36.md)
    * [37 | 贪心算法：如何用贪心算法实现Huffman压缩编码？](the-beauty-of-data-structure-and-algorithms/ch37.md)
    * [38 | 分治算法：谈一谈大规模计算框架MapReduce中的分治思想](the-beauty-of-data-structure-and-algorithms/ch38.md)
    * [39 | 回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想](the-beauty-of-data-structure-and-algorithms/ch39.md)
    * [40 | 初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？](the-beauty-of-data-structure-and-algorithms/ch40.md)
    * [41 | 动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题](the-beauty-of-data-structure-and-algorithms/ch41.md)
    * [42 | 动态规划实战：如何实现搜索引擎中的拼写纠错功能？](the-beauty-of-data-structure-and-algorithms/ch42.md)
    * [43 | 拓扑排序：如何确定代码源文件的编译依赖关系？](the-beauty-of-data-structure-and-algorithms/ch43.md)
    * [44 | 最短路径：地图软件是如何计算出最优出行路径的？](the-beauty-of-data-structure-and-algorithms/ch44.md)
    * [45 | 位图：如何实现网页爬虫中的URL去重功能？](the-beauty-of-data-structure-and-algorithms/ch45.md)
    * [46 | 概率统计：如何利用朴素贝叶斯算法过滤垃圾短信？](the-beauty-of-data-structure-and-algorithms/ch46.md)
    * [47 | 向量空间：如何实现一个简单的音乐推荐系统？](the-beauty-of-data-structure-and-algorithms/ch47.md)
    * [48 | B+树：MySQL数据库索引是如何实现的？](the-beauty-of-data-structure-and-algorithms/ch48.md)
    * [49 | 搜索：如何用``A*``搜索算法实现游戏中的寻路功能？](the-beauty-of-data-structure-and-algorithms/ch49.md)
    * [50 | 索引：如何在海量数据中快速查找某个数据？](the-beauty-of-data-structure-and-algorithms/ch50.md)
    * [51 | 并行算法：如何利用并行处理提高算法的执行效率？](the-beauty-of-data-structure-and-algorithms/ch51.md)
    * [52 | 算法实战（一）：剖析Redis常用数据类型对应的数据结构](the-beauty-of-data-structure-and-algorithms/ch52.md)
    * [53 | 算法实战（二）：剖析搜索引擎背后的经典数据结构和算法](the-beauty-of-data-structure-and-algorithms/ch53.md)
    * [54 | 算法实战（三）：剖析高性能队列Disruptor背后的数据结构和算法](the-beauty-of-data-structure-and-algorithms/ch54.md)
    * [55 | 算法实战（四）：剖析微服务接口鉴权限流背后的数据结构和算法](the-beauty-of-data-structure-and-algorithms/ch55.md)
    * [56 | 算法实战（五）：如何用学过的数据结构和算法实现一个短网址系统？](the-beauty-of-data-structure-and-algorithms/ch56.md)
* [Android开发高手课](android-performance-matters/readme.md)
	* [01 | 崩溃优化（上）](android-performance-matters/ch01.md)
	* [02 | 崩溃优化（下）](android-performance-matters/ch02.md)
	* [03 | 内存优化（上）](android-performance-matters/ch03.md)
	* [04 | 内存优化（下）](android-performance-matters/ch04.md)
	* [05 | 卡顿优化（上）](android-performance-matters/ch05.md)
	* [06 | 卡顿优化（下）](android-performance-matters/ch06.md)
	* [07 | 启动优化（上）](android-performance-matters/ch07.md)
	* [08 | 启动优化（下）](android-performance-matters/ch08.md)
	* [09 | I/O优化（上）](android-performance-matters/ch09.md)
	* [10 | I/O优化（中）](android-performance-matters/ch10.md)
	* [11 | I/O优化（下）](android-performance-matters/ch11.md)
	* [12 | 存储优化（上）](android-performance-matters/ch12.md)
	* [13 | 存储优化（中）](android-performance-matters/ch13.md)
	* [14 | 存储优化（下）](android-performance-matters/ch14.md)
	* [15 | 网络优化（上）](android-performance-matters/ch15.md)
	* [16 | 网络优化（中）](android-performance-matters/ch16.md)
	* [17 | 网络优化（下）](android-performance-matters/ch17.md)
	* [18 | 耗电优化（上）](android-performance-matters/ch18.md)
	* [19 | 耗电优化（下）](android-performance-matters/ch19.md)
	* [20 | UI优化（上）](android-performance-matters/ch20.md)
	* [21 | UI优化（下）](android-performance-matters/ch21.md)
	* [22 | 包体积优化（上）](android-performance-matters/ch22.md)
	* [23 | 包体积优化（下）](android-performance-matters/ch23.md)
	* [24 | 想成为Android高手，你需要先搞定这三个问题](android-performance-matters/ch24.md)
	* [25 | 如何提升组织与个人的研发效能？](android-performance-matters/ch25.md)
	* [26 | 关于编译，你需要了解什么？](android-performance-matters/ch26.md)
	* [27 | 编译插桩的三种方法：AspectJ、ASM、ReDex](android-performance-matters/ch27.md)
	* [28 | 大数据与AI，如何高效地测试？](android-performance-matters/ch28.md)
	* [29 | 从每月到每天，如何给版本发布提速？](android-performance-matters/ch29.md)
	* [30 | 数据评估（上）：如何实现高可用的上报组件？](android-performance-matters/ch30.md)
	* [31 | 数据评估（下）：什么是大数据平台？](android-performance-matters/ch31.md)
	* [32 | 线上疑难问题该如何排查和跟踪？](android-performance-matters/ch32.md)
	* [33 | 做一名有高度的移动开发工程师](android-performance-matters/ch33.md)
	* [34 | 聊聊重构：优秀的架构都是演进而来的](android-performance-matters/ch34.md)
	* [35 | Native Hook 技术，天使还是魔鬼？](android-performance-matters/ch35.md)
	* [36 | 跨平台开发的现状与应用](android-performance-matters/ch36.md)
	* [37 | 移动开发新大陆：工作三年半，移动开发转型手游开发](android-performance-matters/ch37.md)
	* [37 | 移动开发新大陆：工作三年半，移动开发转型手游开发](android-performance-matters/ch38.md)
	* [39 | 移动开发新大陆： 边缘智能计算的趋势](android-performance-matters/ch39.md)
	* [40 | 动态化实践，如何选择适合自己的方案？](android-performance-matters/ch40.md)
	* [41 | 聊聊Flutter，面对层出不穷的新技术该如何跟进？](android-performance-matters/ch41.md)
	* [42 | Android开发高手课学习心得](android-performance-matters/ch42.md)
* [一课掌握Kotlin 突破开发语言瓶颈](kotlin-basics/readme.md)
    * [1.课程导学与准备工作](kotlin-basics/ch01.md)
    * [2.开发环境搭建](kotlin-basics/ch02.md)
    * [3.内置类型](kotlin-basics/ch03.md)
    * [4.类型初步](kotlin-basics/ch04.md)
    * [5.表达式](kotlin-basics/ch05.md)
    * [6.函数进阶](kotlin-basics/ch06.md)
    * [7.类型进阶](kotlin-basics/ch07.md)
    * [8.Kotlin泛型](kotlin-basics/ch08.md)
    * [9.Kotlin反射](kotlin-basics/ch09.md)
    * [10.Kotlin注解](kotlin-basics/ch10.md)
    * [11.协程初步](kotlin-basics/ch11.md)
    * [12.协程进阶](kotlin-basics/ch12.md)
    * [13.协程应用](kotlin-basics/ch13.md)
* [操作系统实战45讲](os-in-action/readme.md)
    * [00 | 开篇词 | 为什么要学写一个操作系统？](os-in-action/00.md)
    * [01 | 程序的运行过程：从代码到机器运行](os-in-action/01.md)
    * [02 | 几行汇编几行C：实现一个最简单的内核](os-in-action/02.md)
    * [03 | 黑盒之中有什么：内核结构与设计](os-in-action/03.md)
    * [04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？](os-in-action/04.md)
    * [05 | CPU工作模式：执行程序的三种模式](os-in-action/05.md)
    * [06 | 虚幻与真实：程序中的地址如何转换？](os-in-action/06.md)
    * [07 | Cache与内存：程序放在哪儿？](os-in-action/07.md)
    * [08 | 锁：并发操作中，解决数据同步的四种方法](os-in-action/08.md)
    * [09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？](os-in-action/09.md)
    * [10 | 设置工作模式与环境（上）：建立计算机](os-in-action/10.md)
    * [11 | 设置工作模式与环境（中）：建造二级引导器](os-in-action/11.md)
    * [12 | 设置工作模式与环境（下）：探查和收集信息](os-in-action/12.md)
    * [13 | 第一个C函数：如何实现板级初始化？](os-in-action/13.md)
    * [14 | Linux初始化（上）：GRUB与vmlinuz的结构](os-in-action/14.md)
    * [15 | Linux初始化（下）：从_start到第一个进程](os-in-action/15.md)
    * [16 | 划分土地（上）：如何划分与组织内存？](os-in-action/16.md)
    * [17 | 划分土地（中）：如何实现内存页面初始化？](os-in-action/17.md)
    * [18 | 划分土地（下）：如何实现内存页的分配与释放？](os-in-action/18.md)
    * [19 | 土地不能浪费：如何管理内存对象？](os-in-action/19.md)
    * [20 | 土地需求扩大与保障：如何表示虚拟内存？](os-in-action/20.md)
    * [21 | 土地需求扩大与保障：如何分配和释放虚拟内存？](os-in-action/21.md)
    * [22 | 瞧一瞧Linux：伙伴系统如何分配内存？](os-in-action/22.md)
    * [23 | 瞧一瞧Linux：SLAB如何分配内存？](os-in-action/23.md)
    * [24 | 活动的描述：到底什么是进程？](os-in-action/24.md)
    * [25 | 多个活动要安排（上）：多进程如何调度？](os-in-action/25.md)
    * [26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？](os-in-action/26.md)
    * [27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?](os-in-action/27.md)
    * [28 | 部门分类：如何表示设备类型与设备驱动？](os-in-action/28.md)
    * [29 | 部门建立：如何在内核中注册设备？](os-in-action/29.md)
    * [30 | 部门响应：设备如何处理内核I/O包？](os-in-action/30.md)
    * [31 | 瞧一瞧Linux：如何获取所有设备信息？](os-in-action/31.md)
    * [32 | 仓库结构：如何组织文件?](os-in-action/32.md)
    * [33 | 仓库划分：文件系统的格式化操作](os-in-action/33.md)
    * [34 | 仓库管理：如何实现文件的六大基本操作？](os-in-action/34.md)
    * [35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？](os-in-action/35.md)
    * [36 | 从URL到网卡：如何全局观察网络数据流动？](os-in-action/36.md)
    * [37 | 从内核到应用：网络数据在内核中如何流转](os-in-action/37.md)
    * [38 | 从单排到团战：详解操作系统的宏观网络架构](os-in-action/38.md)
    * [39 | 瞧一瞧Linux：详解socket实现与网络编程接口](os-in-action/39.md)
    * [40 | 瞧一瞧Linux：详解socket的接口实现](os-in-action/40.md)
    * [41 | 服务接口：如何搭建沟通桥梁？](os-in-action/41.md)
    * [42 | 瞧一瞧Linux：如何实现系统API？](os-in-action/42.md)
    * [43 | 虚拟机内核：KVM是什么？](os-in-action/43.md)
    * [44 | 容器：如何理解容器的实现机制？](os-in-action/44.md)
    * [45 | ARM新宠：苹果的M1芯片因何而快？](os-in-action/45.md)
    * [46 | AArch64体系：ARM最新编程架构模型剖析](os-in-action/46.md)
* [设计模式之美](the-beauty-of-design-pattern/readme.md)
	* [开篇词 | 一对一的设计与编码集训，让你告别没有成长的烂代码！](the-beauty-of-design-pattern/ch000.md)
	* [01 | 为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？](the-beauty-of-design-pattern/ch001.md)
	* [02 | 从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？](the-beauty-of-design-pattern/ch002.md)
	* [03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？](the-beauty-of-design-pattern/ch003.md)
	* [04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？](the-beauty-of-design-pattern/ch004.md)
	* [05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？](the-beauty-of-design-pattern/ch005.md)
	* [06 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？](the-beauty-of-design-pattern/ch006.md)
	* [07 | 理论四：哪些代码设计看似是面向对象，实际是面向过程的？](the-beauty-of-design-pattern/ch007.md)
	* [08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？](the-beauty-of-design-pattern/ch008.md)
	* [09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？](the-beauty-of-design-pattern/ch009.md)
	* [10 | 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？](the-beauty-of-design-pattern/ch010.md)
	* [11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？](the-beauty-of-design-pattern/ch011.md)
	* [12 | 实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？](the-beauty-of-design-pattern/ch012.md)
	* [13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？](the-beauty-of-design-pattern/ch013.md)
	* [14 | 实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？](the-beauty-of-design-pattern/ch014.md)
	* [15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？](the-beauty-of-design-pattern/ch015.md)
	* [16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？](the-beauty-of-design-pattern/ch016.md)
	* [17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？](the-beauty-of-design-pattern/ch017.md)
	* [18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？](the-beauty-of-design-pattern/ch018.md)
	* [19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？](the-beauty-of-design-pattern/ch019.md)
	* [20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？](the-beauty-of-design-pattern/ch020.md)
	* [21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？](the-beauty-of-design-pattern/ch021.md)
	* [22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？](the-beauty-of-design-pattern/ch022.md)
	* [23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？](the-beauty-of-design-pattern/ch023.md)
	* [24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？](the-beauty-of-design-pattern/ch024.md)
	* [25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？](the-beauty-of-design-pattern/ch025.md)
	* [26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？](the-beauty-of-design-pattern/ch026.md)
	* [27 | 理论一：什么情况下要重构？到底重构什么？又该如何重构？](the-beauty-of-design-pattern/ch027.md)
	* [28 | 理论二：为了保证重构不出错，有哪些非常能落地的技术手段？](the-beauty-of-design-pattern/ch028.md)
	* [29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？](the-beauty-of-design-pattern/ch029.md)
	* [30 | 理论四：如何通过封装、抽象、模块化、中间层等解耦代码？](the-beauty-of-design-pattern/ch030.md)
	* [31 | 理论五：让你最快速地改善代码质量的20条编程规范（上）](the-beauty-of-design-pattern/ch031.md)
	* [32 | 理论五：让你最快速地改善代码质量的20条编程规范（中）](the-beauty-of-design-pattern/ch032.md)
	* [33 | 理论五：让你最快速地改善代码质量的20条编程规范（下）](the-beauty-of-design-pattern/ch033.md)
	* [34 | 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题](the-beauty-of-design-pattern/ch034.md)
	* [35 | 实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”](the-beauty-of-design-pattern/ch035.md)
	* [36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？](the-beauty-of-design-pattern/ch036.md)
	* [37 | 实战二（下）：重构ID生成器项目中各函数的异常处理代码](the-beauty-of-design-pattern/ch037.md)
	* [38 | 总结回顾面向对象、设计原则、编程规范、重构技巧等知识点](the-beauty-of-design-pattern/ch038.md)
	* [39 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（上）](the-beauty-of-design-pattern/ch039.md)
	* [40 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（下）](the-beauty-of-design-pattern/ch040.md)
	* [41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？](the-beauty-of-design-pattern/ch041.md)
	* [42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？](the-beauty-of-design-pattern/ch042.md)
	* [43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？](the-beauty-of-design-pattern/ch043.md)
	* [44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？](the-beauty-of-design-pattern/ch044.md)
	* [45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？](the-beauty-of-design-pattern/ch045.md)
	* [46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式](the-beauty-of-design-pattern/ch046.md)
	* [47 | 原型模式：如何最快速地clone一个HashMap散列表？](the-beauty-of-design-pattern/ch047.md)
	* [48 | 代理模式：代理在RPC、缓存、监控等场景中的应用](the-beauty-of-design-pattern/ch048.md)
	* [49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？](the-beauty-of-design-pattern/ch049.md)
	* [50 | 装饰器模式：通过剖析Java IO类库源码学习装饰器模式](the-beauty-of-design-pattern/ch050.md)
	* [51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？](the-beauty-of-design-pattern/ch051.md)
	* [52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？](the-beauty-of-design-pattern/ch052.md)
	* [53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？](the-beauty-of-design-pattern/ch053.md)
	* [54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？](the-beauty-of-design-pattern/ch054.md)
	* [55 | 享元模式（下）：剖析享元模式在Java Integer、String中的应用](the-beauty-of-design-pattern/ch055.md)
	* [56 | 观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式](the-beauty-of-design-pattern/ch056.md)
	* [57 | 观察者模式（下）：如何实现一个异步非阻塞的EventBus框架？](the-beauty-of-design-pattern/ch057.md)
	* [58 | 模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中的应用](the-beauty-of-design-pattern/ch058.md)
	* [59 | 模板模式（下）：模板模式与Callback回调函数有何区别和联系？](the-beauty-of-design-pattern/ch059.md)
	* [60 | 策略模式（上）：如何避免冗长的if-else/switch分支判断代码？](the-beauty-of-design-pattern/ch060.md)
	* [61 | 策略模式（下）：如何实现一个支持给不同大小文件排序的小程序？](the-beauty-of-design-pattern/ch061.md)
	* [62 | 职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框架？](the-beauty-of-design-pattern/ch062.md)
	* [63 | 职责链模式（下）：框架中常用的过滤器、拦截器是如何实现的？](the-beauty-of-design-pattern/ch063.md)
	* [64 | 状态模式：游戏、工作流引擎中常用的状态机是如何实现的？](the-beauty-of-design-pattern/ch064.md)
	* [65 | 迭代器模式（上）：相比直接遍历集合数据，使用迭代器有哪些优势？](the-beauty-of-design-pattern/ch065.md)
	* [66 | 迭代器模式（中）：遍历集合的同时，为什么不能增删集合元素？](the-beauty-of-design-pattern/ch066.md)
	* [67 | 迭代器模式（下）：如何设计实现一个支持“快照”功能的iterator？](the-beauty-of-design-pattern/ch067.md)
	* [68 | 访问者模式（上）：手把手带你还原访问者模式诞生的思维过程](the-beauty-of-design-pattern/ch068.md)
	* [69 | 访问者模式（下）：为什么支持双分派的语言不需要访问者模式？](the-beauty-of-design-pattern/ch069.md)
	* [70 | 备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？](the-beauty-of-design-pattern/ch070.md)
	* [71 | 命令模式：如何利用命令模式实现一个手游后端架构？](the-beauty-of-design-pattern/ch071.md)
	* [72 | 解释器模式：如何设计实现一个自定义接口告警规则功能？](the-beauty-of-design-pattern/ch072.md)
	* [73 | 中介模式：什么时候用中介模式？什么时候用观察者模式？](the-beauty-of-design-pattern/ch073.md)
	* [74 | 总结回顾23种经典设计模式的原理、背后的思想、应用场景等](the-beauty-of-design-pattern/ch074.md)
	* [75 | 在实际的项目开发中，如何避免过度设计？又如何避免设计不足？](the-beauty-of-design-pattern/ch075.md)
	* [76 | 开源实战一（上）：通过剖析Java JDK源码学习灵活应用设计模式](the-beauty-of-design-pattern/ch076.md)
	* [77 | 开源实战一（下）：通过剖析Java JDK源码学习灵活应用设计模式](the-beauty-of-design-pattern/ch077.md)
	* [78 | 开源实战二（上）：从Unix开源开发学习应对大型复杂项目开发](the-beauty-of-design-pattern/ch078.md)
	* [79 | 开源实战二（中）：从Unix开源开发学习应对大型复杂项目开发](the-beauty-of-design-pattern/ch079.md)
	* [80 | 开源实战二（下）：从Unix开源开发学习应对大型复杂项目开发](the-beauty-of-design-pattern/ch080.md)
	* [81 | 开源实战三（上）：借Google Guava学习发现和开发通用功能模块](the-beauty-of-design-pattern/ch081.md)
	* [82 | 开源实战三（中）：剖析Google Guava中用到的几种设计模式](the-beauty-of-design-pattern/ch082.md)
	* [83 | 开源实战三（下）：借Google Guava学习三大编程范式中的函数式编程](the-beauty-of-design-pattern/ch083.md)
	* [84 | 开源实战四（上）：剖析Spring框架中蕴含的经典设计思想或原则](the-beauty-of-design-pattern/ch084.md)
	* [85 | 开源实战四（中）：剖析Spring框架中用来支持扩展的两种设计模式](the-beauty-of-design-pattern/ch085.md)
	* [86 | 开源实战四（下）：总结Spring框架用到的11种设计模式](the-beauty-of-design-pattern/ch086.md)
	* [87 | 开源实战五（上）：MyBatis如何权衡易用性、性能和灵活性？](the-beauty-of-design-pattern/ch087.md)
	* [88 | 开源实战五（中）：如何利用职责链与代理模式实现MyBatis Plugin？](the-beauty-of-design-pattern/ch088.md)
	* [89 | 开源实战五（下）：总结MyBatis框架中用到的10种设计模式](the-beauty-of-design-pattern/ch089.md)
	* [90 | 项目实战一：设计实现一个支持各种算法的限流框架（分析）](the-beauty-of-design-pattern/ch090.md)
	* [91 | 项目实战一：设计实现一个支持各种算法的限流框架（设计）](the-beauty-of-design-pattern/ch091.md)
	* [92 | 项目实战一：设计实现一个支持各种算法的限流框架（实现）](the-beauty-of-design-pattern/ch092.md)
	* [93 | 项目实战二：设计实现一个通用的接口幂等框架（分析）](the-beauty-of-design-pattern/ch093.md)
	* [94 | 项目实战二：设计实现一个通用的接口幂等框架（设计）](the-beauty-of-design-pattern/ch094.md)
	* [95 | 项目实战二：设计实现一个通用的接口幂等框架（实现）](the-beauty-of-design-pattern/ch095.md)
	* [96 | 项目实战三：设计实现一个支持自定义规则的灰度发布组件（分析）](the-beauty-of-design-pattern/ch096.md)
	* [97 | 项目实战三：设计实现一个支持自定义规则的灰度发布组件（设计）](the-beauty-of-design-pattern/ch097.md)
	* [98 | 项目实战三：设计实现一个支持自定义规则的灰度发布组件（实现）](the-beauty-of-design-pattern/ch098.md)
	* [99 | 总结回顾：在实际软件开发中常用的设计思想、原则和模式](the-beauty-of-design-pattern/ch099.md)
	* [100 | 如何将设计思想、原则、模式等理论知识应用到项目中？](the-beauty-of-design-pattern/ch100.md)
	* [加餐一 | 用一篇文章带你了解专栏中用到的所有Java语法](the-beauty-of-design-pattern/ch101.md)
	* [加餐二 | 设计模式、重构、编程规范等相关书籍推荐](the-beauty-of-design-pattern/ch102.md)
	* [春节特别加餐 | 王争：如何学习《设计模式之美》专栏？](the-beauty-of-design-pattern/ch103.md)
	* [加餐三 | 聊一聊Google是如何做Code Review的](the-beauty-of-design-pattern/ch104.md)
	* [加餐四 | 聊一聊Google那些让我快速成长的地方](the-beauty-of-design-pattern/ch105.md)
	* [加餐五 | 听一听小争哥对Google工程师文化的解读](the-beauty-of-design-pattern/ch106.md)
	* [加餐六 | 什么才是所谓的编程能力？如何考察一个人的编程能力？](the-beauty-of-design-pattern/ch107.md)
	* [加餐七 | 基础学科的知识如何转化成实际的技术生产力？](the-beauty-of-design-pattern/ch108.md)
	* [加餐八 | 程序员怎么才能让自己走得更高、更远？](the-beauty-of-design-pattern/ch109.md)
	* [加餐九 | 作为面试官或候选人，如何面试或回答设计模式问题？](the-beauty-of-design-pattern/ch110.md)
	* [加餐十 | 如何接手一坨烂业务代码？如何在烂业务代码中成长？](the-beauty-of-design-pattern/ch111.md)
	* [结束语 | 聊一聊机遇、方向、能力、努力！](the-beauty-of-design-pattern/ch112.md)
* [操作系统实战45讲](operate-system-in-action/readme.md)
	* [开篇词 | 为什么要学写一个操作系统？](operate-system-in-action/ch00.md)
	* [01 | 程序的运行过程：从代码到机器运行](operate-system-in-action/ch01.md)
	* [02 | 几行汇编几行C：实现一个最简单的内核](operate-system-in-action/ch02.md)
	* [03 | 黑盒之中有什么：内核结构与设计](operate-system-in-action/ch03.md)
	* [04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？](operate-system-in-action/ch04.md)
	* [05 | CPU工作模式：执行程序的三种模式](operate-system-in-action/ch05.md)
	* [06 | 虚幻与真实：程序中的地址如何转换？](operate-system-in-action/ch06.md)
	* [07 | Cache与内存：程序放在哪儿？](operate-system-in-action/ch07.md)
	* [08 | 锁：并发操作中，解决数据同步的四种方法](operate-system-in-action/ch08.md)
	* [09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？](operate-system-in-action/ch09.md)
	* [10 | 设置工作模式与环境（上）：建立计算机](operate-system-in-action/ch10.md)
	* [11 | 设置工作模式与环境（中）：建造二级引导器](operate-system-in-action/ch11.md)
	* [12 | 设置工作模式与环境（下）：探查和收集信息](operate-system-in-action/ch12.md)
	* [13 | 第一个C函数：如何实现板级初始化？](operate-system-in-action/ch13.md)
	* [14 | Linux初始化（上）：GRUB与vmlinuz的结构](operate-system-in-action/ch14.md)
	* [15 | Linux初始化（下）：从_start到第一个进程](operate-system-in-action/ch15.md)
	* [16 | 划分土地（上）：如何划分与组织内存？](operate-system-in-action/ch16.md)
	* [17 | 划分土地（中）：如何实现内存页面初始化？](operate-system-in-action/ch17.md)
	* [18 | 划分土地（下）：如何实现内存页的分配与释放？](operate-system-in-action/ch18.md)
	* [19 | 土地不能浪费：如何管理内存对象？](operate-system-in-action/ch19.md)
	* [20 | 土地需求扩大与保障：如何表示虚拟内存？](operate-system-in-action/ch20.md)
	* [21 | 土地需求扩大与保障：如何分配和释放虚拟内存？](operate-system-in-action/ch21.md)
	* [22 | 瞧一瞧Linux：伙伴系统如何分配内存？](operate-system-in-action/ch22.md)
	* [23 | 瞧一瞧Linux：SLAB如何分配内存？](operate-system-in-action/ch23.md)
	* [24 | 活动的描述：到底什么是进程？](operate-system-in-action/ch24.md)
	* [25 | 多个活动要安排（上）：多进程如何调度？](operate-system-in-action/ch25.md)
	* [26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？](operate-system-in-action/ch26.md)
	* [27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?](operate-system-in-action/ch27.md)
	* [28 | 部门分类：如何表示设备类型与设备驱动？](operate-system-in-action/ch28.md)
	* [29 | 部门建立：如何在内核中注册设备？](operate-system-in-action/ch29.md)
	* [30 | 部门响应：设备如何处理内核I/O包？](operate-system-in-action/ch30.md)
	* [31 | 瞧一瞧Linux：如何获取所有设备信息？](operate-system-in-action/ch31.md)
	* [32 | 仓库结构：如何组织文件?](operate-system-in-action/ch32.md)
	* [33 | 仓库划分：文件系统的格式化操作](operate-system-in-action/ch33.md)
	* [34 | 仓库管理：如何实现文件的六大基本操作？](operate-system-in-action/ch34.md)
	* [35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？](operate-system-in-action/ch35.md)
	* [36 | 从URL到网卡：如何全局观察网络数据流动？](operate-system-in-action/ch36.md)
	* [37 | 从内核到应用：网络数据在内核中如何流转](operate-system-in-action/ch37.md)
	* [38 | 从单排到团战：详解操作系统的宏观网络架构](operate-system-in-action/ch38.md)
	* [39 | 瞧一瞧Linux：详解socket实现与网络编程接口](operate-system-in-action/ch39.md)
	* [用户故事 | 成为面向“知识库”的工程师](operate-system-in-action/ch40.md)
