# Summary

* [Introduction](readme.md)
* [Java并发编程实战](java-concurrency-in-practice/readme.md)
    * [开篇词](java-concurrency-in-practice/intro.md)
    * [01.可见性、原子性和有序性问题](java-concurrency-in-practice/ch01.md)
    * [02.Java内存模型](java-concurrency-in-practice/ch02.md)
    * [03.互斥锁上](java-concurrency-in-practice/ch03.md)
    * [04.互斥锁下](java-concurrency-in-practice/ch04.md)
    * [05.死锁](java-concurrency-in-practice/ch05.md)
    * [06.等待通知](java-concurrency-in-practice/ch06.md)
    * [07.安全性、活跃性以及性能问题](java-concurrency-in-practice/ch07.md)
    * [08.管程](java-concurrency-in-practice/ch08.md)
    * [09.Java线程上](java-concurrency-in-practice/ch09.md)
    * [10.Java线程中](java-concurrency-in-practice/ch10.md)
    * [11.Java线程下](java-concurrency-in-practice/ch11.md)
    * [12.面向对象](java-concurrency-in-practice/ch12.md)
    * [13.理论基础答疑](java-concurrency-in-practice/ch13.md)
    * [14.Lock和Condition上](java-concurrency-in-practice/ch14.md)
    * [15.Lock和Condition下](java-concurrency-in-practice/ch15.md)
    * [16.Semaphore](java-concurrency-in-practice/ch16.md)
    * [17.ReadWriteLock](java-concurrency-in-practice/ch17.md)
    * [18.StampedLock](java-concurrency-in-practice/ch18.md)
    * [19.CountDownLatch和CyclicBarrier](java-concurrency-in-practice/ch19.md)
    * [20.并发容器](java-concurrency-in-practice/ch20.md)
    * [21.原子类](java-concurrency-in-practice/ch21.md)
    * [22.Executor与线程池](java-concurrency-in-practice/ch22.md)
    * [23.Future](java-concurrency-in-practice/ch23.md)
    * [24.CompletableFuture](java-concurrency-in-practice/ch24.md)
    * [25.CompletionService](java-concurrency-in-practice/ch25.md)
    * [26.Fork/Join](java-concurrency-in-practice/ch26.md)
    * [27.并发工具类答疑](java-concurrency-in-practice/ch27.md)
    * [28.Immutability模式](java-concurrency-in-practice/ch28.md)
    * [29.Copy-on-Write模式](java-concurrency-in-practice/ch29.md)
    * [30.线程本地存储](java-concurrency-in-practice/ch30.md)
    * [31.Guarded Suspension模式](java-concurrency-in-practice/ch31.md)
    * [32.Balking模式](java-concurrency-in-practice/ch32.md)
    * [33.Thread-Per-Message模式](java-concurrency-in-practice/ch33.md)
* [Java核心技术36讲](core-java/readme.md)
    * [01.对Java平台的理解](core-java/ch01.md)
    * [02.Exception/Error](core-java/ch02.md)
    * [03.final,finally,finalize](core-java/ch03.md)
    * [04.强、软、弱、虚引用](core-java/ch04.md)
    * [05.String,StringBuffer,StringBuilder](core-java/ch05.md)
    * [06.动态代理](core-java/ch06.md)
    * [07.int,Integer](core-java/ch07.md)
    * [08.Vector,ArrayList,LinkedList](core-java/ch08.md)
    * [09.Hashtable,HashMap,TreeMap](core-java/ch09.md)
    * [10.ConcurrentHashMap](core-java/ch10.md)
    * [11.IO/NIO](core-java/ch11.md)
    * [12.文件拷贝方式](core-java/ch12.md)
    * [13.接口和抽象类](core-java/ch13.md)
    * [14.设计模式](core-java/ch14.md)
    * [15.synchronized/ReentrantLock](core-java/ch15.md)
    * [16.synchronized底层实现](core-java/ch16.md)
    * [17.线程调用两次start](core-java/ch17.md)
    * [18.死锁](core-java/ch18.md)
    * [19.Java并发工具类](core-java/ch19.md)
    * [20.ConcurrentLinkedQueue和LinkedBlockingQueue区别](core-java/ch20.md)
    * [21.线程池](core-java/ch21.md)
    * [22.AtomicInteger底层实现原理](core-java/ch22.md)
    * [23.类加载过程](core-java/ch23.md)
    * [24.运行时动态生成Java类](core-java/ch24.md)
    * [25.JVM内存区域划分](core-java/ch25.md)
    * [26.监控和诊断JVM对内和堆外内存使用](core-java/ch26.md)
    * [27.Java常见垃圾收集器](core-java/ch27.md)
    * [28.GC调优思路](core-java/ch28.md)
    * [29.Java内存模型happen-before](core-java/ch29.md)
    * [30.Java&Docker](core-java/ch30.md)
    * [31.Java应用开发中注入攻击](core-java/ch31.md)
    * [32.安全Java代码](core-java/ch32.md)
    * [33.诊断后台服务](core-java/ch33.md)
    * [34.Lambda](core-java/ch34.md)
    * [35.JVM优化Java代码](core-java/ch35.md)
    * [36.MySQL支持的事务隔离级别](core-java/ch36.md)
    * [37.Spring Bean生命周期](core-java/ch37.md)
    * [38.Netty&NIO](core-java/ch38.md)
    * [39.分布式ID](core-java/ch39.md)
    * [40.书籍](core-java/ch40.md)
* [深入拆解Java虚拟机](deep-into-jvm/readme.md)
    * [开篇词 | 为什么我们要学习Java虚拟机？](deep-into-jvm/ch00.md)
    * [01 | Java代码是怎么运行的？](deep-into-jvm/ch01.md)
    * [02 | Java的基本类型](deep-into-jvm/ch02.md)
    * [03 | Java虚拟机是如何加载Java类的?](deep-into-jvm/ch03.md)
    * [04 | JVM是如何执行方法调用的？（上）](deep-into-jvm/ch04.md)
    * [05 | JVM是如何执行方法调用的？（下）](deep-into-jvm/ch05.md)
    * [06 | JVM是如何处理异常的？](deep-into-jvm/ch06.md)
    * [07 | JVM是如何实现反射的？](deep-into-jvm/ch07.md)
    * [08 | JVM是怎么实现invokedynamic的？（上）](deep-into-jvm/ch08.md)
    * [09 | JVM是怎么实现invokedynamic的？（下）](deep-into-jvm/ch09.md)
    * [10 | Java对象的内存布局](deep-into-jvm/ch10.md)
    * [11 | 垃圾回收（上）](deep-into-jvm/ch11.md)
    * [12 | 垃圾回收（下）](deep-into-jvm/ch12.md)
    * [13 | Java内存模型](deep-into-jvm/ch13.md)
    * [14 | Java虚拟机是怎么实现synchronized的？](deep-into-jvm/ch14.md)
    * [15 | Java语法糖与Java编译器](deep-into-jvm/ch15.md)
    * [16 | 即时编译（上）](deep-into-jvm/ch16.md)
    * [17 | 即时编译（下）](deep-into-jvm/ch17.md)
    * [18 | 即时编译器的中间表达形式](deep-into-jvm/ch18.md)
    * [19 | Java字节码（基础篇）](deep-into-jvm/ch19.md)
    * [20 | 方法内联（上）](deep-into-jvm/ch20.md)
    * [21 | 方法内联（下）](deep-into-jvm/ch21.md)
    * [22 | HotSpot虚拟机的intrinsic](deep-into-jvm/ch22.md)
    * [23 | 逃逸分析](deep-into-jvm/ch23.md)
    * [24 | 字段访问相关优化](deep-into-jvm/ch24.md)
    * [25 | 循环优化](deep-into-jvm/ch25.md)
    * [26 | 向量化](deep-into-jvm/ch26.md)
    * [27 | 注解处理器](deep-into-jvm/ch27.md)
    * [28 | 基准测试框架JMH（上）](deep-into-jvm/ch28.md)
    * [29 | 基准测试框架JMH（下）](deep-into-jvm/ch29.md)
    * [30 | Java虚拟机的监控及诊断工具（命令行篇）](deep-into-jvm/ch30.md)
    * [31 | Java虚拟机的监控及诊断工具（GUI篇）](deep-into-jvm/ch31.md)
    * [32 | JNI的运行机制](deep-into-jvm/ch32.md)
    * [33 | Java Agent与字节码注入](deep-into-jvm/ch33.md)
    * [34 | Graal：用Java编译Java](deep-into-jvm/ch34.md)
    * [35 | Truffle：语言实现框架](deep-into-jvm/ch35.md)
    * [36 | SubstrateVM：AOT编译框架](deep-into-jvm/ch36.md)
    * [尾声 | 道阻且长，努力加餐](deep-into-jvm/ch37.md)
* [数据结构与算法之美](the-beauty-of-data-structure-and-algorithms/readme.md)
    * [开篇词 | 从今天起，跨过“数据结构与算法”这道坎](the-beauty-of-data-structure-and-algorithms/ch00.md)
    * [01 | 为什么要学习数据结构和算法？](the-beauty-of-data-structure-and-algorithms/ch01.md)
    * [02 | 如何抓住重点，系统高效地学习数据结构与算法？](the-beauty-of-data-structure-and-algorithms/ch02.md)
    * [03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？](the-beauty-of-data-structure-and-algorithms/ch03.md)
    * [04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度](the-beauty-of-data-structure-and-algorithms/ch04.md)
    * [05 | 数组：为什么很多编程语言中数组都从0开始编号？](the-beauty-of-data-structure-and-algorithms/ch05.md)
    * [06 | 链表（上）：如何实现LRU缓存淘汰算法?](the-beauty-of-data-structure-and-algorithms/ch06.md)
    * [07 | 链表（下）：如何轻松写出正确的链表代码？](the-beauty-of-data-structure-and-algorithms/ch07.md)
    * [08 | 栈：如何实现浏览器的前进和后退功能？](the-beauty-of-data-structure-and-algorithms/ch08.md)
    * [09 | 队列：队列在线程池等有限资源池中的应用](the-beauty-of-data-structure-and-algorithms/ch09.md)
    * [10 | 递归：如何用三行代码找到“最终推荐人”？](the-beauty-of-data-structure-and-algorithms/ch10.md)
    * [11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？](the-beauty-of-data-structure-and-algorithms/ch11.md)
    * [12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？](the-beauty-of-data-structure-and-algorithms/ch12.md)
    * [13 | 线性排序：如何根据年龄给100万用户数据排序？](the-beauty-of-data-structure-and-algorithms/ch13.md)
    * [14 | 排序优化：如何实现一个通用的、高性能的排序函数？](the-beauty-of-data-structure-and-algorithms/ch14.md)
    * [15 | 二分查找（上）：如何用最省内存的方式实现快速查找功能？](the-beauty-of-data-structure-and-algorithms/ch15.md)
    * [16 | 二分查找（下）：如何快速定位IP对应的省份地址？](the-beauty-of-data-structure-and-algorithms/ch16.md)
    * [17 | 跳表：为什么Redis一定要用跳表来实现有序集合？](the-beauty-of-data-structure-and-algorithms/ch17.md)
    * [18 | 散列表（上）：Word文档中的单词拼写检查功能是如何实现的？](the-beauty-of-data-structure-and-algorithms/ch18.md)
    * [19 | 散列表（中）：如何打造一个工业级水平的散列表？](the-beauty-of-data-structure-and-algorithms/ch19.md)
    * [20 | 散列表（下）：为什么散列表和链表经常会一起使用？](the-beauty-of-data-structure-and-algorithms/ch20.md)
    * [21 | 哈希算法（上）：如何防止数据库中的用户信息被脱库？](the-beauty-of-data-structure-and-algorithms/ch21.md)
    * [22 | 哈希算法（下）：哈希算法在分布式系统中有哪些应用？](the-beauty-of-data-structure-and-algorithms/ch22.md)
    * [23 | 二叉树基础（上）：什么样的二叉树适合用数组来存储？](the-beauty-of-data-structure-and-algorithms/ch23.md)
    * [24 | 二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？](the-beauty-of-data-structure-and-algorithms/ch24.md)
    * [25 | 红黑树（上）：为什么工程中都用红黑树这种二叉树？](the-beauty-of-data-structure-and-algorithms/ch25.md)
    * [26 | 红黑树（下）：掌握这些技巧，你也可以实现一个红黑树](the-beauty-of-data-structure-and-algorithms/ch26.md)
    * [27 | 递归树：如何借助树来求解递归算法的时间复杂度？](the-beauty-of-data-structure-and-algorithms/ch27.md)
    * [28 | 堆和堆排序：为什么说堆排序没有快速排序快？](the-beauty-of-data-structure-and-algorithms/ch28.md)
    * [29 | 堆的应用：如何快速获取到Top 10最热门的搜索关键词？](the-beauty-of-data-structure-and-algorithms/ch29.md)
    * [30 | 图的表示：如何存储微博、微信等社交网络中的好友关系？](the-beauty-of-data-structure-and-algorithms/ch30.md)
    * [31 | 深度和广度优先搜索：如何找出社交网络中的三度好友关系？](the-beauty-of-data-structure-and-algorithms/ch31.md)
    * [32 | 字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？](the-beauty-of-data-structure-and-algorithms/ch32.md)
    * [33 | 字符串匹配基础（中）：如何实现文本编辑器中的查找功能？](the-beauty-of-data-structure-and-algorithms/ch33.md)
    * [34 | 字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法？](the-beauty-of-data-structure-and-algorithms/ch34.md)
    * [35 | Trie树：如何实现搜索引擎的搜索关键词提示功能？](the-beauty-of-data-structure-and-algorithms/ch35.md)
    * [36 | AC自动机：如何用多模式串匹配实现敏感词过滤功能？](the-beauty-of-data-structure-and-algorithms/ch36.md)
    * [37 | 贪心算法：如何用贪心算法实现Huffman压缩编码？](the-beauty-of-data-structure-and-algorithms/ch37.md)
    * [38 | 分治算法：谈一谈大规模计算框架MapReduce中的分治思想](the-beauty-of-data-structure-and-algorithms/ch38.md)
    * [39 | 回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想](the-beauty-of-data-structure-and-algorithms/ch39.md)
    * [40 | 初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？](the-beauty-of-data-structure-and-algorithms/ch40.md)
    * [41 | 动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题](the-beauty-of-data-structure-and-algorithms/ch41.md)
    * [42 | 动态规划实战：如何实现搜索引擎中的拼写纠错功能？](the-beauty-of-data-structure-and-algorithms/ch42.md)
    * [43 | 拓扑排序：如何确定代码源文件的编译依赖关系？](the-beauty-of-data-structure-and-algorithms/ch43.md)
    * [44 | 最短路径：地图软件是如何计算出最优出行路径的？](the-beauty-of-data-structure-and-algorithms/ch44.md)
    * [45 | 位图：如何实现网页爬虫中的URL去重功能？](the-beauty-of-data-structure-and-algorithms/ch45.md)
    * [46 | 概率统计：如何利用朴素贝叶斯算法过滤垃圾短信？](the-beauty-of-data-structure-and-algorithms/ch46.md)
    * [47 | 向量空间：如何实现一个简单的音乐推荐系统？](the-beauty-of-data-structure-and-algorithms/ch47.md)
    * [48 | B+树：MySQL数据库索引是如何实现的？](the-beauty-of-data-structure-and-algorithms/ch48.md)
    * [49 | 搜索：如何用``A*``搜索算法实现游戏中的寻路功能？](the-beauty-of-data-structure-and-algorithms/ch49.md)
    * [50 | 索引：如何在海量数据中快速查找某个数据？](the-beauty-of-data-structure-and-algorithms/ch50.md)
    * [51 | 并行算法：如何利用并行处理提高算法的执行效率？](the-beauty-of-data-structure-and-algorithms/ch51.md)
    * [52 | 算法实战（一）：剖析Redis常用数据类型对应的数据结构](the-beauty-of-data-structure-and-algorithms/ch52.md)
    * [53 | 算法实战（二）：剖析搜索引擎背后的经典数据结构和算法](the-beauty-of-data-structure-and-algorithms/ch53.md)
    * [54 | 算法实战（三）：剖析高性能队列Disruptor背后的数据结构和算法](the-beauty-of-data-structure-and-algorithms/ch54.md)
    * [55 | 算法实战（四）：剖析微服务接口鉴权限流背后的数据结构和算法](the-beauty-of-data-structure-and-algorithms/ch55.md)
    * [56 | 算法实战（五）：如何用学过的数据结构和算法实现一个短网址系统？](the-beauty-of-data-structure-and-algorithms/ch56.md)
* [Android开发高手课](android-performance-matters/readme.md)
	* [01 | 崩溃优化（上）](android-performance-matters/ch01.md)
	* [02 | 崩溃优化（下）](android-performance-matters/ch02.md)
	* [03 | 内存优化（上）](android-performance-matters/ch03.md)
	* [04 | 内存优化（下）](android-performance-matters/ch04.md)
	* [05 | 卡顿优化（上）](android-performance-matters/ch05.md)
	* [06 | 卡顿优化（下）](android-performance-matters/ch06.md)
	* [07 | 启动优化（上）](android-performance-matters/ch07.md)
	* [08 | 启动优化（下）](android-performance-matters/ch08.md)
	* [09 | I/O优化（上）](android-performance-matters/ch09.md)
	* [10 | I/O优化（中）](android-performance-matters/ch10.md)
	* [11 | I/O优化（下）](android-performance-matters/ch11.md)
	* [12 | 存储优化（上）](android-performance-matters/ch12.md)
	* [13 | 存储优化（中）](android-performance-matters/ch13.md)
	* [14 | 存储优化（下）](android-performance-matters/ch14.md)
	* [15 | 网络优化（上）](android-performance-matters/ch15.md)
	* [16 | 网络优化（中）](android-performance-matters/ch16.md)
	* [17 | 网络优化（下）](android-performance-matters/ch17.md)
	* [18 | 耗电优化（上）](android-performance-matters/ch18.md)
	* [19 | 耗电优化（下）](android-performance-matters/ch19.md)
	* [20 | UI优化（上）](android-performance-matters/ch20.md)
	* [21 | UI优化（下）](android-performance-matters/ch21.md)
	* [22 | 包体积优化（上）](android-performance-matters/ch22.md)
	* [23 | 包体积优化（下）](android-performance-matters/ch23.md)
	* [24 | 想成为Android高手，你需要先搞定这三个问题](android-performance-matters/ch24.md)
	* [25 | 如何提升组织与个人的研发效能？](android-performance-matters/ch25.md)
	* [26 | 关于编译，你需要了解什么？](android-performance-matters/ch26.md)
	* [27 | 编译插桩的三种方法：AspectJ、ASM、ReDex](android-performance-matters/ch27.md)
	* [28 | 大数据与AI，如何高效地测试？](android-performance-matters/ch28.md)
	* [29 | 从每月到每天，如何给版本发布提速？](android-performance-matters/ch29.md)
	* [30 | 数据评估（上）：如何实现高可用的上报组件？](android-performance-matters/ch30.md)
	* [31 | 数据评估（下）：什么是大数据平台？](android-performance-matters/ch31.md)
	* [32 | 线上疑难问题该如何排查和跟踪？](android-performance-matters/ch32.md)
	* [33 | 做一名有高度的移动开发工程师](android-performance-matters/ch33.md)
	* [34 | 聊聊重构：优秀的架构都是演进而来的](android-performance-matters/ch34.md)
	* [35 | Native Hook 技术，天使还是魔鬼？](android-performance-matters/ch35.md)
	* [36 | 跨平台开发的现状与应用](android-performance-matters/ch36.md)
	* [37 | 移动开发新大陆：工作三年半，移动开发转型手游开发](android-performance-matters/ch37.md)
	* [37 | 移动开发新大陆：工作三年半，移动开发转型手游开发](android-performance-matters/ch38.md)
	* [39 | 移动开发新大陆： 边缘智能计算的趋势](android-performance-matters/ch39.md)
	* [40 | 动态化实践，如何选择适合自己的方案？](android-performance-matters/ch40.md)
	* [41 | 聊聊Flutter，面对层出不穷的新技术该如何跟进？](android-performance-matters/ch41.md)
	* [42 | Android开发高手课学习心得](android-performance-matters/ch42.md)
* [一课掌握Kotlin 突破开发语言瓶颈](kotlin-basics/readme.md)
    * [1.课程导学与准备工作](kotlin-basics/ch01.md)
    * [2.开发环境搭建](kotlin-basics/ch02.md)
    * [3.内置类型](kotlin-basics/ch03.md)
    * [4.类型初步](kotlin-basics/ch04.md)
    * [5.表达式](kotlin-basics/ch05.md)
    * [6.函数进阶](kotlin-basics/ch06.md)
    * [7.类型进阶](kotlin-basics/ch07.md)
    * [8.Kotlin泛型](kotlin-basics/ch08.md)
    * [9.Kotlin反射](kotlin-basics/ch09.md)
    * [10.Kotlin注解](kotlin-basics/ch10.md)
    * [11.协程初步](kotlin-basics/ch11.md)
    * [12.协程进阶](kotlin-basics/ch12.md)
    * [13.协程应用](kotlin-basics/ch13.md)
* [操作系统实战45讲](os-in-action/readme.md)
    * [00 | 开篇词 | 为什么要学写一个操作系统？](os-in-action/00.md)
    * [01 | 程序的运行过程：从代码到机器运行](os-in-action/01.md)
    * [02 | 几行汇编几行C：实现一个最简单的内核](os-in-action/02.md)
    * [03 | 黑盒之中有什么：内核结构与设计](os-in-action/03.md)
    * [04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？](os-in-action/04.md)
    * [05 | CPU工作模式：执行程序的三种模式](os-in-action/05.md)
    * [06 | 虚幻与真实：程序中的地址如何转换？](os-in-action/06.md)
    * [07 | Cache与内存：程序放在哪儿？](os-in-action/07.md)
    * [08 | 锁：并发操作中，解决数据同步的四种方法](os-in-action/08.md)
    * [09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？](os-in-action/09.md)
    * [10 | 设置工作模式与环境（上）：建立计算机](os-in-action/10.md)
    * [11 | 设置工作模式与环境（中）：建造二级引导器](os-in-action/11.md)
    * [12 | 设置工作模式与环境（下）：探查和收集信息](os-in-action/12.md)
    * [13 | 第一个C函数：如何实现板级初始化？](os-in-action/13.md)
    * [14 | Linux初始化（上）：GRUB与vmlinuz的结构](os-in-action/14.md)
    * [15 | Linux初始化（下）：从_start到第一个进程](os-in-action/15.md)
    * [16 | 划分土地（上）：如何划分与组织内存？](os-in-action/16.md)
    * [17 | 划分土地（中）：如何实现内存页面初始化？](os-in-action/17.md)
    * [18 | 划分土地（下）：如何实现内存页的分配与释放？](os-in-action/18.md)
    * [19 | 土地不能浪费：如何管理内存对象？](os-in-action/19.md)
    * [20 | 土地需求扩大与保障：如何表示虚拟内存？](os-in-action/20.md)
    * [21 | 土地需求扩大与保障：如何分配和释放虚拟内存？](os-in-action/21.md)
    * [22 | 瞧一瞧Linux：伙伴系统如何分配内存？](os-in-action/22.md)
    * [23 | 瞧一瞧Linux：SLAB如何分配内存？](os-in-action/23.md)
    * [24 | 活动的描述：到底什么是进程？](os-in-action/24.md)
    * [25 | 多个活动要安排（上）：多进程如何调度？](os-in-action/25.md)
    * [26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？](os-in-action/26.md)
    * [27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?](os-in-action/27.md)
    * [28 | 部门分类：如何表示设备类型与设备驱动？](os-in-action/28.md)
    * [29 | 部门建立：如何在内核中注册设备？](os-in-action/29.md)
    * [30 | 部门响应：设备如何处理内核I/O包？](os-in-action/30.md)
    * [31 | 瞧一瞧Linux：如何获取所有设备信息？](os-in-action/31.md)
    * [32 | 仓库结构：如何组织文件?](os-in-action/32.md)
    * [33 | 仓库划分：文件系统的格式化操作](os-in-action/33.md)
    * [34 | 仓库管理：如何实现文件的六大基本操作？](os-in-action/34.md)
    * [35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？](os-in-action/35.md)
    * [36 | 从URL到网卡：如何全局观察网络数据流动？](os-in-action/36.md)
    * [37 | 从内核到应用：网络数据在内核中如何流转](os-in-action/37.md)
    * [38 | 从单排到团战：详解操作系统的宏观网络架构](os-in-action/38.md)
    * [39 | 瞧一瞧Linux：详解socket实现与网络编程接口](os-in-action/39.md)
    * [40 | 瞧一瞧Linux：详解socket的接口实现](os-in-action/40.md)
    * [41 | 服务接口：如何搭建沟通桥梁？](os-in-action/41.md)
    * [42 | 瞧一瞧Linux：如何实现系统API？](os-in-action/42.md)
    * [43 | 虚拟机内核：KVM是什么？](os-in-action/43.md)
    * [44 | 容器：如何理解容器的实现机制？](os-in-action/44.md)
    * [45 | ARM新宠：苹果的M1芯片因何而快？](os-in-action/45.md)
    * [46 | AArch64体系：ARM最新编程架构模型剖析](os-in-action/46.md)
